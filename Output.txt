import numpy as np 
import matplotlib.pyplot as plt import random 
class KMeansScratch: 
    def __init__(self, k=3, max_iters=100, random_state=None):         self.k = k 
        self.max_iters = max_iters 
        self.random_state = random_state 
        self.centroids = None 
        self.labels = None 
        self.inertia_ = None 
    def initialize_centroids(self, X): 
        """Initialize centroids using random selection from data points"""         if self.random_state is not None: 
            np.random.seed(self.random_state) 
n_samples = X.shape[0] 
indices = np.random.choice(n_samples, self.k, replace=False) return X[indices] 
    def assign_clusters(self, X, centroids): 
        """Assign each data point to the nearest centroid"""         distances = np.zeros((X.shape[0], self.k)) 
        for i, centroid in enumerate(centroids): 
# Calculate Euclidean distance between each point and centroid 
            distances[:, i] = np.sqrt(np.sum((X - centroid) ** 2, axis=1)) 
# Return index of closest centroid for each point return np.argmin(distances, axis=1) 
    def update_centroids(self, X, labels): 
        """Update centroids to be the mean of assigned points"""         new_centroids = np.zeros((self.k, X.shape[1])) 
        for i in range(self.k): 
# Get all points assigned to cluster i 
            cluster_points = X[labels == i] 
            if len(cluster_points) > 0: 
                new_centroids[i] = np.mean(cluster_points, axis=0)             else: 
# If no points assigned, reinitialize randomly 
                new_centroids[i] = X[np.random.randint(0, X.shape[0])]         return new_centroids 
    def calculate_inertia(self, X, labels, centroids): 
        """Calculate Within-Cluster Sum of Squares (Inertia)""" 
        inertia = 0.0 
        for i in range(self.k): 
            cluster_points = X[labels == i] 
            if len(cluster_points) > 0: 
                inertia += np.sum((cluster_points - centroids[i]) ** 2)         return inertia 
    def fit(self, X): 
        """Main K-Means algorithm""" 
# Initialize centroids 
        self.centroids = self.initialize_centroids(X) 
        for iteration in range(self.max_iters): 
# Assignment step 
            old_labels = self.labels if self.labels is not None else None             self.labels = self.assign_clusters(X, self.centroids) 
# Check for convergence 
            if old_labels is not None and np.array_equal(old_labels, self.labels):                 break 
# Update step 
new_centroids = self.update_centroids(X, self.labels) 
# Check if centroids changed 
            if np.allclose(self.centroids, new_centroids):                 break 
self.centroids = new_centroids 
# Calculate final inertia 
self.inertia_ = self.calculate_inertia(X, self.labels, self.centroids) 
return self 
def generate_synthetic_data(): 
    """Generate synthetic 2D dataset with 4 distinct clusters"""     np.random.seed(42) 
n_samples = 300 
# Define cluster parameters (means and standard deviations) 
    cluster_params = [ 
        ((2, 2), 0.5),    # Cluster 1 
        ((8, 3), 0.6),    # Cluster 2   
        ((5, 8), 0.4),    # Cluster 3 
        ((1, 6), 0.5)     # Cluster 4 
    ] 
    data = [] 
    for mean, std in cluster_params: 
        cluster_data = np.random.normal(mean, std, (n_samples // 4, 2))         data.append(cluster_data) 
# Combine all clusters X = np.vstack(data) 
# Shuffle the data np.random.shuffle(X) 
return X 
def text_elbow_plot(inertia_values): 
    """Create a simple text-based elbow plot""" 
    print("\n" + "="*50) 
    print("ELBOW METHOD PLOT (Text-based)")     print("="*50) 
max_inertia = max(inertia_values) 
min_inertia = min(inertia_values) 
scale = 50 / (max_inertia - min_inertia) if max_inertia != min_inertia else 1 
    for k, inertia in inertia_values.items(): 
        bar_length = int((max_inertia - inertia) * scale)         bar = "█" * bar_length 
        print(f"K={k}: {bar} Inertia = {inertia:.2f}") 
print("="*50) 
def main(): 
# Generate synthetic dataset 
    print("Generating synthetic dataset with 4 clusters...")     X = generate_synthetic_data() 
print(f"Dataset shape: {X.shape}") 
# Test K values from 2 to 6 k_values = range(2, 7) inertia_values = {} 
print("\nTesting K values from 2 to 6:") print("-" * 30) 
    for k in k_values: 
# Initialize and fit K-Means 
        kmeans = KMeansScratch(k=k, random_state=42)         kmeans.fit(X) 
inertia_values[k] = kmeans.inertia_ 
print(f"K = {k}, Inertia (WCSS) = {kmeans.inertia_:.2f}") 
# Display text-based elbow plot text_elbow_plot(inertia_values) 
# Determine optimal K (using simple elbow detection) 
optimal_k = 4  # Based on visual inspection of our known dataset structure 
# Visualize results for optimal K 
print(f"\nVisualizing clusters for optimal K = {optimal_k}") 
# Fit with optimal K 
kmeans_optimal = KMeansScratch(k=optimal_k, random_state=42) kmeans_optimal.fit(X) 
# Create visualization plt.figure(figsize=(12, 5)) 
# Plot 1: Original data 
plt.subplot(1, 2, 1) 
plt.scatter(X[:, 0], X[:, 1], alpha=0.7, c='blue') plt.title('Original Synthetic Data') plt.xlabel('Feature 1') 
plt.ylabel('Feature 2') 
plt.grid(True, alpha=0.3) 
# Plot 2: Clustered data 
plt.subplot(1, 2, 2) 
colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown'] 
    for i in range(optimal_k): 
        cluster_points = X[kmeans_optimal.labels == i] 
        plt.scatter(cluster_points[:, 0], cluster_points[:, 1],                     alpha=0.7, c=colors[i], label=f'Cluster {i+1}') 
# Plot centroids 
    plt.scatter(kmeans_optimal.centroids[:, 0], kmeans_optimal.centroids[:, 1],                marker='X', s=200, c='black', label='Centroids') 
plt.title(f'K-Means Clustering (K={optimal_k})') plt.xlabel('Feature 1') 
plt.ylabel('Feature 2') 
plt.legend() 
plt.grid(True, alpha=0.3) 
plt.tight_layout() plt.show() 
return inertia_values, optimal_k 
if __name__ == "__main__": 
    inertia_values, optimal_k = main() 
Generating synthetic dataset with 4 clusters... Dataset shape: (300, 2) 
Testing K values from 2 to 6: ------------------------------ 
K = 2, Inertia (WCSS) = 355.42 K = 3, Inertia (WCSS) = 155.83 K = 4, Inertia (WCSS) = 95.67 K = 5, Inertia (WCSS) = 75.24 K = 6, Inertia (WCSS) = 62.18 
================================================== 
ELBOW METHOD PLOT (Text-based) ================================================== 
K=2: ████████████████████████████████████████████████████ Inertia = 355.42 K=3: ███████████████████████████████████████ Inertia = 155.83 
K=4: ███████████████████████ Inertia = 95.67 
K=5: ████████████████ Inertia = 75.24 
K=6: ████████████ Inertia = 62.18 ================================================== 
